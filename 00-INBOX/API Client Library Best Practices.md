
> *Building an API client library for a third-party service with incomplete documentation while maintaining schema-driven development principles is a challenging circular dependency problem. Here's a comprehensive approach to navigate this complexity systematically.*

## Contents

## Core Challenge

One of the more common development patterns in modern web development and software engineering is the need to integrate with third party APIs. In order to best do this, developers and engineers attempting to implement [schema-driven development](schema-driven development.md) patterns rely on a complete, comprehensive [OpenAPI Specification](OpenAPI Specification.md) to bootstrap their project. When a specification is not available or is incomplete or invalid, the developer must [reverse engineer](reverse engineer.md) the various schemas and endpoints through a very intricate process. This creates inherent tension between the ideal of [API First Development](API First Development.md) and the reality of incomplete third-party documentation and specifications.

## Tools

- [mitmproxy](mitmproxy.md)
- [mitmproxy2swagger](mitmproxy2swagger.md)
- [demystify](demystify.md)
- [httr2](httr2.md) and `httr2::req_proxy()`
- [OpenAPI Specification](OpenAPI Specification.md)
- [HAR Archive](HAR Archive.md)
- [HTTP](HTTP.md)
- [Proxy](Proxy.md) and [Reverse Proxy](Reverse Proxy.md)
- [ApiDog](ApiDog.md)
- [Charles Proxy](Charles Proxy.md)
- [ProxyMan](ProxyMan.md)
- [JSON Schema](JSON Schema.md)
- [Redocly CLI](Redocly CLI.md)
- [Arazzo Specification](Arazzo Specification.md)
- [LLM](LLM.md)
- [OpenAI](OpenAI.md)
- [Schema Evolution](Schema Evolution.md)
- [CICD](CICD.md)
- [DevOps](DevOps.md)
- 

